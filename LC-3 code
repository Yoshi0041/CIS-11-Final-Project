.ORIG x3000

;JUMP SUBROUTINES

JSR GETAVERAGE_GRADE 
JSR GETMINIMUM_GRADE
JSR GETMAXIMUM_GRADE
JSR GETLETTER_GRADE

HALT								;END PROGRAM




;CALCULATE AVERAGE SCORE

GETAVERAGE_GRADE
AND R1, R1, #0							;CLEAR R1
AND R2, R2, #0							;CLEAR R2
AND R3, R3, #0							;CLEAR R3
ADD R1, R1, #5      						;R1= R1 + #5 ARRAY SIZE
LEA R2, ARRAY			  				;LOAD ARRAY STRING INTO R2



;ADDITION LOOP TO ADD UP ALL THE GRADES

SUMOFSCORESLOOP 			    			;LOOP FOR THE SUM OF SCORES
LDR R0, R2, #0       						;ARRAY + offset
ADD R2, R2, #1       						;INCREMENT COUNTER R2++
ADD R3, R3, R0			     				;COPY R0 VALUE TO R3
ADD R1, R1, #-1 			    			;DECREMENT COUNTER R1--
BRp SUMOFSCORESLOOP       					;IF POSITIVE BRANCH TO SUMOFSCORESLOOP


;SAVING OUR VALUE
ST R3, SUMOFSCORES						;STORE R3 IN SUMOFSCORES LABEL

AND R2, R2, #0			    				;CLEAR R2
AND R3, R3, #0			    				;CLEAR R3
LD R1, SUMOFSCORES						;LOAD R1 WITH SUM OF THE SCORES TOTAL

;DIVISION LOOP TO FIND AVERAGE SCORE

AVGOFSCORES_LOOP			        		;BEGINNING OF LOOP
ADD R1, R1, #-5			          			;R1 = R1 - #5
BRn ENDAVGOFSCORESLOOP_END					;IF NEGATIVE GO TO END OF LOOP
ADD R2, R2, #1			          			;R2 = R2 + #1
BR AVGOFSCORES_LOOP			      			;GO TO BEGINNING OF THE LOOP
ENDAVGOFSCORESLOOP_END			  			;END OF LOOP

ST R2, AVERAGESCORE			          		;STORE R2 INTO AVERAGESCORE LABEL
					                  	;RETURN VALUES

;DISPLAY AVERAGE SCORE




AND R0, R0, #0							;CLEAR R0
LEA R0, AVERAGEPROMPT						;LOAD AVERAGEPROMPTINTO R0
PUTS					      			;PRINT

AND R1, R1, #0							;CLEAR R1
AND R2, R2, #0							;CLEAR R2
	
LD R1, AVERAGESCORE						;LOAD AVERAGESCORE INTO R1

DIVLOOP1		
ADD R1, R1, #-10      						;R1 = R1- #10
BRn DIVLOOP1_EXIT 						;KEEP LOOPING IF NOT NEGATIVE
ADD R2, R2, #1     						;INCREMENT COUNTER

BR DIVLOOP1							;KEEP LOOPING

DIVLOOP1_EXIT							;EXIT LOOP

AND R0, R0, #0							;CLEAR R0
ADD R0, R0, R2							;COPY R2 TO R0
LD    R2,ASCII							;LOAD ASCII INTO R2
ADD R0, R0, R2							;R0= R0 + R2	ASCII CONVERSION OF R2 IN R0
OUT

ADD R1, R1, #10							;R1= R1 + 10   (ADD 10 BACK TO GET ONES DIGIT)
ADD R0, R1, R2							;R0= R1 + R2	ASCII CONVERSION FOR ONES DIGIT
OUT



;CALCULATE MINIMUM AND MAXIMUM VALUES



GETMINIMUM_GRADE						;FIND MINIMUM GRADE

AND R0, R0, #0							;CLEAR R0
AND R4, R4, #0							;CLEAR R4
LEA R0, ARRAY							;LOAD ARRAY STRING R0
;ADD R0, R0, #1							;ARRAY OFFSET 
LDR R1, R0, #0 							;LOAD R0 INTO R1


;R1 CURRENT MINIMUM, R2 TO BE CHECKED
MINIMUM_LOOP							;BEGINNING OF LOOP
ADD R4, R4, #1  						;INCREMENT COUNTER
AND R5, R5, #0							;CLEAR R5
ADD R5, R4, #-4							;R5 = R4 - #4
BRzp MINIMUMLOOP_EXIT
ADD R0, R0, #1							; INCREMENT ARRAY ++
LDR R2, R0, #0							;LOAD R0 INTO R2
NOT R2, R2							;1S COMPLEMENT OF R2
ADD R2, R2,	#1						;2S COMPLEMENT OF R2
ADD R3, R1,	R2						;R3= R1 + R2 
BRn MINIMUM_LOOP						;IF NEGATIVE BRANCH TO BEGINNING OF LOOPING
BRzp NEWMINIMUM							;IF BRANCH NEW MINIMUM

NEWMINIMUM							;R1 = R0 CONTINUES TO LOOP THROUGH THE ARRAY
LDR R1, R0, #0
BR MINIMUM_LOOP

MINIMUMLOOP_EXIT						;END OF LOOP
ST R1, MINIMUM_GRADE						;STORES R1 INTO MINIMUM_GRADE LABEL
								;RETURN VALUES

;DISPLAY MINIMUM GRADE


 
LEA R0, MINIMUMPROMPT						;LOAD MINIMUMPROMPT INTO R0
PUTS					      			;PRINT
AND R1, R1, #0							;CLEAR R1
AND R2, R2, #0							;CLEAR R2
	
LD R1, MINIMUM_GRADE						;LOAD MINIMUM_GRADE INTO R1

DIVLOOP2							;DIVLOOP2
ADD R1, R1, #-10   						;R1= MIN - #10   
BRn DIVLOOP2_EXIT 	
ADD R2, R2, #1     						;INCREMENT COUNTER

BR DIVLOOP2							;KEEP LOOPING DIVLOOP

DIVLOOP2_EXIT							;END OF DIVLOOP

AND R0, R0, #0							;CLEAR R0
ADD R0, R0, R2							;COPY R2 TO R0
LD R2, ASCII							;LOAD ASCII INTO R2
ADD R0, R0, R2							;R0= R0 + R2	ASCII CONVERSION OF R2 IN R0
OUT								;PRINT

ADD R1, R1, #10							;R1= R1+ 10   (ADD 10 BACK TO GET ONES DIGIT)
ADD R0, R1, R2							;R0= R1+R2	ASCII CONVERSION FOR ONES DIGIT
OUT






GETMAXIMUM_GRADE						;FIND MAXIMUM GRADE

AND R0, R0, #0							;CLEAR R0
AND R4, R4, #0							;CLEAR R4
LEA R0, ARRAY							;LOAD ARRAY STRING
;ADD R0, R0, #1							;ARRAY OFFSET	
LDR R1,	R0, #0							;LOAD R0 INTO R1

;R1 current min, R2 to be checked
MAXIMUM_LOOP							;BEGINNING OF LOOP
ADD R4, R4, #1  						;INCREMENT COUNTER counter
AND R5, R5, #0							;CLEAR R5
ADD R5, R4, #-4							;R5= R4 - 4
BRzp MAXIMUMLOOP_EXIT						;WHEN ZERO OR POSITIVE END THE LOOP
ADD R0, R0, #1							; ++ ARRAY INDEX
LDR R2,	R0, #0							;LOAD R2 WITH R0
NOT R2,	R2							;1S COMPLEMENT
ADD R2,	R2, #1							;2S COMPLEMENT OF R2
ADD R3, R1, R2							;R3 = R1 + R2
BRp MAXIMUM_LOOP						;IF R3 IS POSITIVE BRANCH TO BEGINNING OF LOOP
BRnz NEWMAXIMUM							;BRANCH NEW MAXIMUM

NEWMAXIMUM				
LDR R1, R0, #0							;LOAD R0 INTO R1
BR MAXIMUM_LOOP

MAXIMUMLOOP_EXIT						;END OF LOOP
ST R1, MAXIMUM_GRADE						;STORE R1 INTO MAXIMUM_GRADE LABEL
								;RETURN VALUES

;DISPLAY MAXIMUM GRADE

LEA R0, MAXIMUMPROMPT						;LOAD MAXIMUMPROMPT INTO R0
PUTS								;PRINT
AND R1, R1, #0							;CLEAR R1
AND R2, R2, #0							;CLEAR R2
	
LD R1, MAXIMUM_GRADE						;LOAD MAXIMUM_GRADE INTO R1

DIVLOOP3							;DIVLOOP 

ADD R1, R1, #-10						;R1= MAXIMUM - 10      
BRn DIVLOOP3_EXIT 
ADD R2, R2, #1     						;INCREMENT COUNTER

BR DIVLOOP3

DIVLOOP3_EXIT

AND R0, R0, #0							;CLEAR R0
ADD R0, R0, R2							;COPY R2 TO R0
LD R2, ASCII							;LOAD ASCII INTO R2
ADD R0, R0, R2							;R0= R0 + R2	ASCII CONVERSION OF R2 IN R0
OUT								;PRINT

ADD R1, R1, #10							;R1= R1+ #10	(ADD 10 BACK TO GET ONES DIGIT)
ADD R0, R1, R2							;R0= R1+R2	ASCII CONVERSION FOR ONES DIGIT
OUT								;PRINT



;subroutine to find the letter grade


GETLETTER_GRADE 						;IF ELSE STATEMENTS TO GET LETTER GRADE


AND R0, R0, #0        						;CLEAR R0
AND R2, R2, #0        						;CLEAR R2
LD R0, AVERAGESCORE   						;LOAD AVERAGESCORE INTO R0
LD R2, GRADES         						;LOAD THE GRADES OFFSETS TO CHECK FOR LETTER
LEA R5, LISTOF_GRADES 						;LOADS THE ARRAY OF THE GRADE LETTERS DETERMINATION
LDR R1,R5,#0
ADD R3,R0,R1            					;AVERAGE < 60 
BRzp GradeD
ADD R2,R2,#5             					;PRINT "F"
BR EXITGRADELETTER
      
GradeD
LDR R1,R5,#1
ADD R3,R0,R1            					;ELSE IF AVERAGE > 60 and < 70
BRzp GradeC
ADD R2,R2,#3             					;PRINT "D"
BR EXITGRADELETTER

GradeC
LDR R1,R5,#2
ADD R3,R0,R1            					;ELSE IF AVERAGE > 70 and < 80
BRzp GradeB
ADD R2,R2,#2             					;PRINT "C"
BR EXITGRADELETTER

GradeB
LDR R1,R5,#3
ADD R3,R0,R1            					;ELSE IF AVERAGE > 80 and < 90
BRzp GradeA
ADD R2,R2,#1            					;PRINT "B"
BR EXITGRADELETTER
GradeA     
ADD R2,R2,#0            					;ELSE PRINT "A"

EXITGRADELETTER
ADD R0,R2,#0
ST R0, LETTER_GRADE
                    						;RETURN VALUES

;DISPLAY LETTER GRADE



LEA R0, LETTERGRADEPROMPT					;LOAD LETTERGRADEPROMPT INTO R0
PUTS								;PRINT
AND R1, R1, #0							;CLEAR R1
AND R0, R0 ,#0                  				;CLEAR R0
LD R1, LETTER_GRADE						;LOAD MAXIMUM INTO R1
ADD R0, R0, R1                  				;COPY R1 TO R0
OUT                             				;PRINT TO CONSOLE









;GRADE INPUT (THIS IS WHERE THE USER FILL VALUES OF THE SCORE) 

ARRAY   
.fill #52   ;52
.fill #87   ;87
.fill #96   ;96
.fill #79   ;79
.fill #61   ;61


;GRADE VALUES FOR THE IF ELSE STATEMENTS

LISTOF_GRADES
.fill #-60
.fill #-70
.fill #-80
.fill #-90

GRADES .fill #65 ;(offset character "A")

;PROMPTS
AVERAGEPROMPT		.STRINGZ	"\nTHE AVERAGE GRADE: "
MINIMUMPROMPT   	.STRINGZ	"\nTHE MINIMUM GRADE: "
MAXIMUMPROMPT		.STRINGZ	"\nTHE MAXIMUM GRADE: "
LETTERGRADEPROMPT 	.STRINGZ        "\nTHE LETTER GRADE: "


;INITIALIZING GRADE SCORES

MAXIMUM_GRADE	.fill #0  
MINIMUM_GRADE	.fill #0
AVERAGESCORE 	.fill #0
LETTER_GRADE  	.fill #0
SUMOFSCORES 	.fill #0
ASCII   	.fill #48    ; ASCII offset

.END
